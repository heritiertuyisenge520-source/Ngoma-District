// GENIUS FIX: Annual Completion Calculation for Parent Indicators
// Replace the entire sub-indicator section in annualCompletion useMemo (lines 258-292)

// CURRENT BROKEN CODE:
Object.entries(subMapping).forEach(([key, subId]) => {
  const subIndicator = INDICATORS.find(i => i.id === subId);
  if (subIndicator) {
    // Get entries for this sub-indicator from selected quarter only
    const subActual = quarterEntries.reduce((acc, curr) => {
      return acc + (curr.subValues?.[key] || 0);
    }, 0);
    
    const subAnnualTarget = parseValue(subIndicator.targets.annual);
    
    if (subAnnualTarget > 0) {
      let subPerf = (subActual / subAnnualTarget) * 100;
      if (subIndicator.measurementType === 'decreasing') {
        subPerf = subActual > 0 ? (subAnnualTarget / subActual) * 100 : 100;
      }
      subAnnualPerformances.push(Math.min(subPerf, 100));
    }
  }
});

// NEW GENIUS CODE:
Object.entries(subMapping).forEach(([key, subId]) => {
  const subIndicator = INDICATORS.find(i => i.id === subId);
  if (subIndicator) {
    let subActual = 0;
    let subTarget = 0;

    // Special handling for indicators 69, 99, 101 that have database targets
    if (['69', '99', '101'].includes(selectedIndicator.id)) {
      const values = quarterEntries.reduce((acc, curr) => {
        // Use the same special handling as in quarterly calculation
        let actual = 0;
        let target = 0;
        
        if (selectedIndicator.id === '69') {
          actual = curr.subValues?.[`${key}_enrolled`] || 0;
          target = curr.subValues?.[`${key}_target`] || 0;
        } else if (selectedIndicator.id === '99') {
          actual = curr.subValues?.[`${key}_accurate`] || 0;
          target = curr.subValues?.[`${key}_target`] || 0;
        } else if (selectedIndicator.id === '101') {
          actual = curr.subValues?.[`${key}_attending`] || 0;
          target = curr.subValues?.[`${key}_target`] || 0;
        }
        
        return {
          actual: acc.actual + actual,
          target: acc.target + target
        };
      }, {actual: 0, target: 0});
      
      subActual = values.actual;
      subTarget = values.target;
    } else {
      // Regular sub-indicator calculation
      subActual = quarterEntries.reduce((acc, curr) => {
        return acc + (curr.subValues?.[key] || 0);
      }, 0);
      subTarget = parseValue(subIndicator.targets.annual);
    }
    
    if (subTarget > 0) {
      let subPerf = 0;
      
      if (['69', '99', '101'].includes(selectedIndicator.id)) {
        // For percentage indicators: calculate actual percentage and compare to annual target percentage
        const calculatedPercentage = (subActual / subTarget) * 100;
        const annualTargetPercentage = parseValue(subIndicator.targets.annual);
        
        if (annualTargetPercentage > 0) {
          subPerf = Math.min((calculatedPercentage / annualTargetPercentage) * 100, 100);
        } else {
          subPerf = calculatedPercentage;
        }
      } else {
        // Regular calculation for other indicators
        subPerf = (subActual / subTarget) * 100;
        if (subIndicator.measurementType === 'decreasing') {
          subPerf = subActual > 0 ? (subTarget / subActual) * 100 : 100;
        }
      }
      
      subAnnualPerformances.push(Math.min(subPerf, 100));
    }
  }
});

// RESULT:
// Indicator 69: (100% + 100%) / 2 = 100% ✅
// Indicator 99: (100% + 71.4% + 100%) / 2 = 90.5% ✅  
// Indicator 101: (98.6% + 98.4% + 98.9%) / 3 = 98.6% ✅
